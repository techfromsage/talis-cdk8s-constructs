// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * XBackendTrafficPolicy defines the configuration for how traffic to a
target backend should be handled.
 *
 * @schema XBackendTrafficPolicy
 */
export class XBackendTrafficPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "XBackendTrafficPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gateway.networking.x-k8s.io/v1alpha1',
    kind: 'XBackendTrafficPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "XBackendTrafficPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: XBackendTrafficPolicyProps): any {
    return {
      ...XBackendTrafficPolicy.GVK,
      ...toJson_XBackendTrafficPolicyProps(props),
    };
  }

  /**
   * Defines a "XBackendTrafficPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: XBackendTrafficPolicyProps) {
    super(scope, id, {
      ...XBackendTrafficPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...XBackendTrafficPolicy.GVK,
      ...toJson_XBackendTrafficPolicyProps(resolved),
    };
  }
}

/**
 * XBackendTrafficPolicy defines the configuration for how traffic to a
 * target backend should be handled.
 *
 * @schema XBackendTrafficPolicy
 */
export interface XBackendTrafficPolicyProps {
  /**
   * @schema XBackendTrafficPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec defines the desired state of BackendTrafficPolicy.
   *
   * @schema XBackendTrafficPolicy#spec
   */
  readonly spec: XBackendTrafficPolicySpec;

}

/**
 * Converts an object of type 'XBackendTrafficPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XBackendTrafficPolicyProps(obj: XBackendTrafficPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_XBackendTrafficPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec defines the desired state of BackendTrafficPolicy.
 *
 * @schema XBackendTrafficPolicySpec
 */
export interface XBackendTrafficPolicySpec {
  /**
   * RetryConstraint defines the configuration for when to allow or prevent
   * further retries to a target backend, by dynamically calculating a 'retry
   * budget'. This budget is calculated based on the percentage of incoming
   * traffic composed of retries over a given time interval. Once the budget
   * is exceeded, additional retries will be rejected.
   *
   * For example, if the retry budget interval is 10 seconds, there have been
   * 1000 active requests in the past 10 seconds, and the allowed percentage
   * of requests that can be retried is 20% (the default), then 200 of those
   * requests may be composed of retries. Active requests will only be
   * considered for the duration of the interval when calculating the retry
   * budget. Retrying the same original request multiple times within the
   * retry budget interval will lead to each retry being counted towards
   * calculating the budget.
   *
   * Configuring a RetryConstraint in BackendTrafficPolicy is compatible with
   * HTTPRoute Retry settings for each HTTPRouteRule that targets the same
   * backend. While the HTTPRouteRule Retry stanza can specify whether a
   * request will be retried, and the number of retry attempts each client
   * may perform, RetryConstraint helps prevent cascading failures such as
   * retry storms during periods of consistent failures.
   *
   * After the retry budget has been exceeded, additional retries to the
   * backend MUST return a 503 response to the client.
   *
   * Additional configurations for defining a constraint on retries MAY be
   * defined in the future.
   *
   * Support: Extended
   *
   * @schema XBackendTrafficPolicySpec#retryConstraint
   */
  readonly retryConstraint?: XBackendTrafficPolicySpecRetryConstraint;

  /**
   * SessionPersistence defines and configures session persistence
   * for the backend.
   *
   * Support: Extended
   *
   * @schema XBackendTrafficPolicySpec#sessionPersistence
   */
  readonly sessionPersistence?: XBackendTrafficPolicySpecSessionPersistence;

  /**
   * TargetRefs identifies API object(s) to apply this policy to.
   * Currently, Backends (A grouping of like endpoints such as Service,
   * ServiceImport, or any implementation-specific backendRef) are the only
   * valid API target references.
   *
   * Currently, a TargetRef can not be scoped to a specific port on a
   * Service.
   *
   * @schema XBackendTrafficPolicySpec#targetRefs
   */
  readonly targetRefs: XBackendTrafficPolicySpecTargetRefs[];

}

/**
 * Converts an object of type 'XBackendTrafficPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XBackendTrafficPolicySpec(obj: XBackendTrafficPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'retryConstraint': toJson_XBackendTrafficPolicySpecRetryConstraint(obj.retryConstraint),
    'sessionPersistence': toJson_XBackendTrafficPolicySpecSessionPersistence(obj.sessionPersistence),
    'targetRefs': obj.targetRefs?.map(y => toJson_XBackendTrafficPolicySpecTargetRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RetryConstraint defines the configuration for when to allow or prevent
 * further retries to a target backend, by dynamically calculating a 'retry
 * budget'. This budget is calculated based on the percentage of incoming
 * traffic composed of retries over a given time interval. Once the budget
 * is exceeded, additional retries will be rejected.
 *
 * For example, if the retry budget interval is 10 seconds, there have been
 * 1000 active requests in the past 10 seconds, and the allowed percentage
 * of requests that can be retried is 20% (the default), then 200 of those
 * requests may be composed of retries. Active requests will only be
 * considered for the duration of the interval when calculating the retry
 * budget. Retrying the same original request multiple times within the
 * retry budget interval will lead to each retry being counted towards
 * calculating the budget.
 *
 * Configuring a RetryConstraint in BackendTrafficPolicy is compatible with
 * HTTPRoute Retry settings for each HTTPRouteRule that targets the same
 * backend. While the HTTPRouteRule Retry stanza can specify whether a
 * request will be retried, and the number of retry attempts each client
 * may perform, RetryConstraint helps prevent cascading failures such as
 * retry storms during periods of consistent failures.
 *
 * After the retry budget has been exceeded, additional retries to the
 * backend MUST return a 503 response to the client.
 *
 * Additional configurations for defining a constraint on retries MAY be
 * defined in the future.
 *
 * Support: Extended
 *
 * @schema XBackendTrafficPolicySpecRetryConstraint
 */
export interface XBackendTrafficPolicySpecRetryConstraint {
  /**
   * Budget holds the details of the retry budget configuration.
   *
   * @schema XBackendTrafficPolicySpecRetryConstraint#budget
   */
  readonly budget?: XBackendTrafficPolicySpecRetryConstraintBudget;

  /**
   * MinRetryRate defines the minimum rate of retries that will be allowable
   * over a specified duration of time.
   *
   * The effective overall minimum rate of retries targeting the backend
   * service may be much higher, as there can be any number of clients which
   * are applying this setting locally.
   *
   * This ensures that requests can still be retried during periods of low
   * traffic, where the budget for retries may be calculated as a very low
   * value.
   *
   * Support: Extended
   *
   * @schema XBackendTrafficPolicySpecRetryConstraint#minRetryRate
   */
  readonly minRetryRate?: XBackendTrafficPolicySpecRetryConstraintMinRetryRate;

}

/**
 * Converts an object of type 'XBackendTrafficPolicySpecRetryConstraint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XBackendTrafficPolicySpecRetryConstraint(obj: XBackendTrafficPolicySpecRetryConstraint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'budget': toJson_XBackendTrafficPolicySpecRetryConstraintBudget(obj.budget),
    'minRetryRate': toJson_XBackendTrafficPolicySpecRetryConstraintMinRetryRate(obj.minRetryRate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SessionPersistence defines and configures session persistence
 * for the backend.
 *
 * Support: Extended
 *
 * @schema XBackendTrafficPolicySpecSessionPersistence
 */
export interface XBackendTrafficPolicySpecSessionPersistence {
  /**
   * AbsoluteTimeout defines the absolute timeout of the persistent
   * session. Once the AbsoluteTimeout duration has elapsed, the
   * session becomes invalid.
   *
   * Support: Extended
   *
   * @schema XBackendTrafficPolicySpecSessionPersistence#absoluteTimeout
   */
  readonly absoluteTimeout?: string;

  /**
   * CookieConfig provides configuration settings that are specific
   * to cookie-based session persistence.
   *
   * Support: Core
   *
   * @schema XBackendTrafficPolicySpecSessionPersistence#cookieConfig
   */
  readonly cookieConfig?: XBackendTrafficPolicySpecSessionPersistenceCookieConfig;

  /**
   * IdleTimeout defines the idle timeout of the persistent session.
   * Once the session has been idle for more than the specified
   * IdleTimeout duration, the session becomes invalid.
   *
   * Support: Extended
   *
   * @schema XBackendTrafficPolicySpecSessionPersistence#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * SessionName defines the name of the persistent session token
   * which may be reflected in the cookie or the header. Users
   * should avoid reusing session names to prevent unintended
   * consequences, such as rejection or unpredictable behavior.
   *
   * Support: Implementation-specific
   *
   * @schema XBackendTrafficPolicySpecSessionPersistence#sessionName
   */
  readonly sessionName?: string;

  /**
   * Type defines the type of session persistence such as through
   * the use a header or cookie. Defaults to cookie based session
   * persistence.
   *
   * Support: Core for "Cookie" type
   *
   * Support: Extended for "Header" type
   *
   * @default cookie based session
   * @schema XBackendTrafficPolicySpecSessionPersistence#type
   */
  readonly type?: XBackendTrafficPolicySpecSessionPersistenceType;

}

/**
 * Converts an object of type 'XBackendTrafficPolicySpecSessionPersistence' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XBackendTrafficPolicySpecSessionPersistence(obj: XBackendTrafficPolicySpecSessionPersistence | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'absoluteTimeout': obj.absoluteTimeout,
    'cookieConfig': toJson_XBackendTrafficPolicySpecSessionPersistenceCookieConfig(obj.cookieConfig),
    'idleTimeout': obj.idleTimeout,
    'sessionName': obj.sessionName,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalPolicyTargetReference identifies an API object to apply a direct or
 * inherited policy to. This should be used as part of Policy resources
 * that can target Gateway API resources. For more information on how this
 * policy attachment model works, and a sample Policy resource, refer to
 * the policy attachment documentation for Gateway API.
 *
 * @schema XBackendTrafficPolicySpecTargetRefs
 */
export interface XBackendTrafficPolicySpecTargetRefs {
  /**
   * Group is the group of the target resource.
   *
   * @schema XBackendTrafficPolicySpecTargetRefs#group
   */
  readonly group: string;

  /**
   * Kind is kind of the target resource.
   *
   * @schema XBackendTrafficPolicySpecTargetRefs#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the target resource.
   *
   * @schema XBackendTrafficPolicySpecTargetRefs#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'XBackendTrafficPolicySpecTargetRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XBackendTrafficPolicySpecTargetRefs(obj: XBackendTrafficPolicySpecTargetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Budget holds the details of the retry budget configuration.
 *
 * @schema XBackendTrafficPolicySpecRetryConstraintBudget
 */
export interface XBackendTrafficPolicySpecRetryConstraintBudget {
  /**
   * Interval defines the duration in which requests will be considered
   * for calculating the budget for retries.
   *
   * Support: Extended
   *
   * @schema XBackendTrafficPolicySpecRetryConstraintBudget#interval
   */
  readonly interval?: string;

  /**
   * Percent defines the maximum percentage of active requests that may
   * be made up of retries.
   *
   * Support: Extended
   *
   * @schema XBackendTrafficPolicySpecRetryConstraintBudget#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'XBackendTrafficPolicySpecRetryConstraintBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XBackendTrafficPolicySpecRetryConstraintBudget(obj: XBackendTrafficPolicySpecRetryConstraintBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MinRetryRate defines the minimum rate of retries that will be allowable
 * over a specified duration of time.
 *
 * The effective overall minimum rate of retries targeting the backend
 * service may be much higher, as there can be any number of clients which
 * are applying this setting locally.
 *
 * This ensures that requests can still be retried during periods of low
 * traffic, where the budget for retries may be calculated as a very low
 * value.
 *
 * Support: Extended
 *
 * @schema XBackendTrafficPolicySpecRetryConstraintMinRetryRate
 */
export interface XBackendTrafficPolicySpecRetryConstraintMinRetryRate {
  /**
   * Count specifies the number of requests per time interval.
   *
   * Support: Extended
   *
   * @schema XBackendTrafficPolicySpecRetryConstraintMinRetryRate#count
   */
  readonly count?: number;

  /**
   * Interval specifies the divisor of the rate of requests, the amount of
   * time during which the given count of requests occur.
   *
   * Support: Extended
   *
   * @schema XBackendTrafficPolicySpecRetryConstraintMinRetryRate#interval
   */
  readonly interval?: string;

}

/**
 * Converts an object of type 'XBackendTrafficPolicySpecRetryConstraintMinRetryRate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XBackendTrafficPolicySpecRetryConstraintMinRetryRate(obj: XBackendTrafficPolicySpecRetryConstraintMinRetryRate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'interval': obj.interval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CookieConfig provides configuration settings that are specific
 * to cookie-based session persistence.
 *
 * Support: Core
 *
 * @schema XBackendTrafficPolicySpecSessionPersistenceCookieConfig
 */
export interface XBackendTrafficPolicySpecSessionPersistenceCookieConfig {
  /**
   * LifetimeType specifies whether the cookie has a permanent or
   * session-based lifetime. A permanent cookie persists until its
   * specified expiry time, defined by the Expires or Max-Age cookie
   * attributes, while a session cookie is deleted when the current
   * session ends.
   *
   * When set to "Permanent", AbsoluteTimeout indicates the
   * cookie's lifetime via the Expires or Max-Age cookie attributes
   * and is required.
   *
   * When set to "Session", AbsoluteTimeout indicates the
   * absolute lifetime of the cookie tracked by the gateway and
   * is optional.
   *
   * Defaults to "Session".
   *
   * Support: Core for "Session" type
   *
   * Support: Extended for "Permanent" type
   *
   * @default Session".
   * @schema XBackendTrafficPolicySpecSessionPersistenceCookieConfig#lifetimeType
   */
  readonly lifetimeType?: XBackendTrafficPolicySpecSessionPersistenceCookieConfigLifetimeType;

}

/**
 * Converts an object of type 'XBackendTrafficPolicySpecSessionPersistenceCookieConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XBackendTrafficPolicySpecSessionPersistenceCookieConfig(obj: XBackendTrafficPolicySpecSessionPersistenceCookieConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lifetimeType': obj.lifetimeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type defines the type of session persistence such as through
 * the use a header or cookie. Defaults to cookie based session
 * persistence.
 *
 * Support: Core for "Cookie" type
 *
 * Support: Extended for "Header" type
 *
 * @default cookie based session
 * @schema XBackendTrafficPolicySpecSessionPersistenceType
 */
export enum XBackendTrafficPolicySpecSessionPersistenceType {
  /** Cookie */
  COOKIE = "Cookie",
  /** Header */
  HEADER = "Header",
}

/**
 * LifetimeType specifies whether the cookie has a permanent or
 * session-based lifetime. A permanent cookie persists until its
 * specified expiry time, defined by the Expires or Max-Age cookie
 * attributes, while a session cookie is deleted when the current
 * session ends.
 *
 * When set to "Permanent", AbsoluteTimeout indicates the
 * cookie's lifetime via the Expires or Max-Age cookie attributes
 * and is required.
 *
 * When set to "Session", AbsoluteTimeout indicates the
 * absolute lifetime of the cookie tracked by the gateway and
 * is optional.
 *
 * Defaults to "Session".
 *
 * Support: Core for "Session" type
 *
 * Support: Extended for "Permanent" type
 *
 * @default Session".
 * @schema XBackendTrafficPolicySpecSessionPersistenceCookieConfigLifetimeType
 */
export enum XBackendTrafficPolicySpecSessionPersistenceCookieConfigLifetimeType {
  /** Permanent */
  PERMANENT = "Permanent",
  /** Session */
  SESSION = "Session",
}


/**
 * XListenerSet defines a set of additional listeners
to attach to an existing Gateway.
 *
 * @schema XListenerSet
 */
export class XListenerSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "XListenerSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gateway.networking.x-k8s.io/v1alpha1',
    kind: 'XListenerSet',
  }

  /**
   * Renders a Kubernetes manifest for "XListenerSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: XListenerSetProps): any {
    return {
      ...XListenerSet.GVK,
      ...toJson_XListenerSetProps(props),
    };
  }

  /**
   * Defines a "XListenerSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: XListenerSetProps) {
    super(scope, id, {
      ...XListenerSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...XListenerSet.GVK,
      ...toJson_XListenerSetProps(resolved),
    };
  }
}

/**
 * XListenerSet defines a set of additional listeners
 * to attach to an existing Gateway.
 *
 * @schema XListenerSet
 */
export interface XListenerSetProps {
  /**
   * @schema XListenerSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec defines the desired state of ListenerSet.
   *
   * @schema XListenerSet#spec
   */
  readonly spec: XListenerSetSpec;

}

/**
 * Converts an object of type 'XListenerSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XListenerSetProps(obj: XListenerSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_XListenerSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec defines the desired state of ListenerSet.
 *
 * @schema XListenerSetSpec
 */
export interface XListenerSetSpec {
  /**
   * Listeners associated with this ListenerSet. Listeners define
   * logical endpoints that are bound on this referenced parent Gateway's addresses.
   *
   * Listeners in a `Gateway` and their attached `ListenerSets` are concatenated
   * as a list when programming the underlying infrastructure. Each listener
   * name does not need to be unique across the Gateway and ListenerSets.
   * See ListenerEntry.Name for more details.
   *
   * Implementations MUST treat the parent Gateway as having the merged
   * list of all listeners from itself and attached ListenerSets using
   * the following precedence:
   *
   * 1. "parent" Gateway
   * 2. ListenerSet ordered by creation time (oldest first)
   * 3. ListenerSet ordered alphabetically by “{namespace}/{name}”.
   *
   * An implementation MAY reject listeners by setting the ListenerEntryStatus
   * `Accepted`` condition to False with the Reason `TooManyListeners`
   *
   * If a listener has a conflict, this will be reported in the
   * Status.ListenerEntryStatus setting the `Conflicted` condition to True.
   *
   * Implementations SHOULD be cautious about what information from the
   * parent or siblings are reported to avoid accidentally leaking
   * sensitive information that the child would not otherwise have access
   * to. This can include contents of secrets etc.
   *
   * @schema XListenerSetSpec#listeners
   */
  readonly listeners: XListenerSetSpecListeners[];

  /**
   * ParentRef references the Gateway that the listeners are attached to.
   *
   * @schema XListenerSetSpec#parentRef
   */
  readonly parentRef: XListenerSetSpecParentRef;

}

/**
 * Converts an object of type 'XListenerSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XListenerSetSpec(obj: XListenerSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listeners': obj.listeners?.map(y => toJson_XListenerSetSpecListeners(y)),
    'parentRef': toJson_XListenerSetSpecParentRef(obj.parentRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema XListenerSetSpecListeners
 */
export interface XListenerSetSpecListeners {
  /**
   * AllowedRoutes defines the types of routes that MAY be attached to a
   * Listener and the trusted namespaces where those Route resources MAY be
   * present.
   *
   * Although a client request may match multiple route rules, only one rule
   * may ultimately receive the request. Matching precedence MUST be
   * determined in order of the following criteria:
   *
   * * The most specific match as defined by the Route type.
   * * The oldest Route based on creation timestamp. For example, a Route with
   * a creation timestamp of "2020-09-08 01:02:03" is given precedence over
   * a Route with a creation timestamp of "2020-09-08 01:02:04".
   * * If everything else is equivalent, the Route appearing first in
   * alphabetical order (namespace/name) should be given precedence. For
   * example, foo/bar is given precedence over foo/baz.
   *
   * All valid rules within a Route attached to this Listener should be
   * implemented. Invalid Route rules can be ignored (sometimes that will mean
   * the full Route). If a Route rule transitions from valid to invalid,
   * support for that Route rule should be dropped to ensure consistency. For
   * example, even if a filter specified by a Route rule is invalid, the rest
   * of the rules within that Route should still be supported.
   *
   * @schema XListenerSetSpecListeners#allowedRoutes
   */
  readonly allowedRoutes?: XListenerSetSpecListenersAllowedRoutes;

  /**
   * Hostname specifies the virtual hostname to match for protocol types that
   * define this concept. When unspecified, all hostnames are matched. This
   * field is ignored for protocols that don't require hostname based
   * matching.
   *
   * Implementations MUST apply Hostname matching appropriately for each of
   * the following protocols:
   *
   * * TLS: The Listener Hostname MUST match the SNI.
   * * HTTP: The Listener Hostname MUST match the Host header of the request.
   * * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
   * protocol layers as described above. If an implementation does not
   * ensure that both the SNI and Host header match the Listener hostname,
   * it MUST clearly document that.
   *
   * For HTTPRoute and TLSRoute resources, there is an interaction with the
   * `spec.hostnames` array. When both listener and route specify hostnames,
   * there MUST be an intersection between the values for a Route to be
   * accepted. For more information, refer to the Route specific Hostnames
   * documentation.
   *
   * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
   * as a suffix match. That means that a match for `*.example.com` would match
   * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
   *
   * @schema XListenerSetSpecListeners#hostname
   */
  readonly hostname?: string;

  /**
   * Name is the name of the Listener. This name MUST be unique within a
   * ListenerSet.
   *
   * Name is not required to be unique across a Gateway and ListenerSets.
   * Routes can attach to a Listener by having a ListenerSet as a parentRef
   * and setting the SectionName
   *
   * @schema XListenerSetSpecListeners#name
   */
  readonly name: string;

  /**
   * Port is the network port. Multiple listeners may use the
   * same port, subject to the Listener compatibility rules.
   *
   * @schema XListenerSetSpecListeners#port
   */
  readonly port: number;

  /**
   * Protocol specifies the network protocol this listener expects to receive.
   *
   * @schema XListenerSetSpecListeners#protocol
   */
  readonly protocol: string;

  /**
   * TLS is the TLS configuration for the Listener. This field is required if
   * the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
   * if the Protocol field is "HTTP", "TCP", or "UDP".
   *
   * The association of SNIs to Certificate defined in GatewayTLSConfig is
   * defined based on the Hostname field for this listener.
   *
   * The GatewayClass MUST use the longest matching SNI out of all
   * available certificates for any TLS handshake.
   *
   * @schema XListenerSetSpecListeners#tls
   */
  readonly tls?: XListenerSetSpecListenersTls;

}

/**
 * Converts an object of type 'XListenerSetSpecListeners' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XListenerSetSpecListeners(obj: XListenerSetSpecListeners | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedRoutes': toJson_XListenerSetSpecListenersAllowedRoutes(obj.allowedRoutes),
    'hostname': obj.hostname,
    'name': obj.name,
    'port': obj.port,
    'protocol': obj.protocol,
    'tls': toJson_XListenerSetSpecListenersTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ParentRef references the Gateway that the listeners are attached to.
 *
 * @schema XListenerSetSpecParentRef
 */
export interface XListenerSetSpecParentRef {
  /**
   * Group is the group of the referent.
   *
   * @schema XListenerSetSpecParentRef#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Gateway".
   *
   * @schema XListenerSetSpecParentRef#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema XListenerSetSpecParentRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referent.  If not present,
   * the namespace of the referent is assumed to be the same as
   * the namespace of the referring object.
   *
   * @schema XListenerSetSpecParentRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'XListenerSetSpecParentRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XListenerSetSpecParentRef(obj: XListenerSetSpecParentRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AllowedRoutes defines the types of routes that MAY be attached to a
 * Listener and the trusted namespaces where those Route resources MAY be
 * present.
 *
 * Although a client request may match multiple route rules, only one rule
 * may ultimately receive the request. Matching precedence MUST be
 * determined in order of the following criteria:
 *
 * * The most specific match as defined by the Route type.
 * * The oldest Route based on creation timestamp. For example, a Route with
 * a creation timestamp of "2020-09-08 01:02:03" is given precedence over
 * a Route with a creation timestamp of "2020-09-08 01:02:04".
 * * If everything else is equivalent, the Route appearing first in
 * alphabetical order (namespace/name) should be given precedence. For
 * example, foo/bar is given precedence over foo/baz.
 *
 * All valid rules within a Route attached to this Listener should be
 * implemented. Invalid Route rules can be ignored (sometimes that will mean
 * the full Route). If a Route rule transitions from valid to invalid,
 * support for that Route rule should be dropped to ensure consistency. For
 * example, even if a filter specified by a Route rule is invalid, the rest
 * of the rules within that Route should still be supported.
 *
 * @schema XListenerSetSpecListenersAllowedRoutes
 */
export interface XListenerSetSpecListenersAllowedRoutes {
  /**
   * Kinds specifies the groups and kinds of Routes that are allowed to bind
   * to this Gateway Listener. When unspecified or empty, the kinds of Routes
   * selected are determined using the Listener protocol.
   *
   * A RouteGroupKind MUST correspond to kinds of Routes that are compatible
   * with the application protocol specified in the Listener's Protocol field.
   * If an implementation does not support or recognize this resource type, it
   * MUST set the "ResolvedRefs" condition to False for this Listener with the
   * "InvalidRouteKinds" reason.
   *
   * Support: Core
   *
   * @schema XListenerSetSpecListenersAllowedRoutes#kinds
   */
  readonly kinds?: XListenerSetSpecListenersAllowedRoutesKinds[];

  /**
   * Namespaces indicates namespaces from which Routes may be attached to this
   * Listener. This is restricted to the namespace of this Gateway by default.
   *
   * Support: Core
   *
   * @schema XListenerSetSpecListenersAllowedRoutes#namespaces
   */
  readonly namespaces?: XListenerSetSpecListenersAllowedRoutesNamespaces;

}

/**
 * Converts an object of type 'XListenerSetSpecListenersAllowedRoutes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XListenerSetSpecListenersAllowedRoutes(obj: XListenerSetSpecListenersAllowedRoutes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kinds': obj.kinds?.map(y => toJson_XListenerSetSpecListenersAllowedRoutesKinds(y)),
    'namespaces': toJson_XListenerSetSpecListenersAllowedRoutesNamespaces(obj.namespaces),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS is the TLS configuration for the Listener. This field is required if
 * the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
 * if the Protocol field is "HTTP", "TCP", or "UDP".
 *
 * The association of SNIs to Certificate defined in GatewayTLSConfig is
 * defined based on the Hostname field for this listener.
 *
 * The GatewayClass MUST use the longest matching SNI out of all
 * available certificates for any TLS handshake.
 *
 * @schema XListenerSetSpecListenersTls
 */
export interface XListenerSetSpecListenersTls {
  /**
   * CertificateRefs contains a series of references to Kubernetes objects that
   * contains TLS certificates and private keys. These certificates are used to
   * establish a TLS handshake for requests that match the hostname of the
   * associated listener.
   *
   * A single CertificateRef to a Kubernetes Secret has "Core" support.
   * Implementations MAY choose to support attaching multiple certificates to
   * a Listener, but this behavior is implementation-specific.
   *
   * References to a resource in different namespace are invalid UNLESS there
   * is a ReferenceGrant in the target namespace that allows the certificate
   * to be attached. If a ReferenceGrant does not allow this reference, the
   * "ResolvedRefs" condition MUST be set to False for this listener with the
   * "RefNotPermitted" reason.
   *
   * This field is required to have at least one element when the mode is set
   * to "Terminate" (default) and is optional otherwise.
   *
   * CertificateRefs can reference to standard Kubernetes resources, i.e.
   * Secret, or implementation-specific custom resources.
   *
   * Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
   *
   * Support: Implementation-specific (More than one reference or other resource types)
   *
   * @schema XListenerSetSpecListenersTls#certificateRefs
   */
  readonly certificateRefs?: XListenerSetSpecListenersTlsCertificateRefs[];

  /**
   * FrontendValidation holds configuration information for validating the frontend (client).
   * Setting this field will require clients to send a client certificate
   * required for validation during the TLS handshake. In browsers this may result in a dialog appearing
   * that requests a user to specify the client certificate.
   * The maximum depth of a certificate chain accepted in verification is Implementation specific.
   *
   * Support: Extended
   *
   * @schema XListenerSetSpecListenersTls#frontendValidation
   */
  readonly frontendValidation?: XListenerSetSpecListenersTlsFrontendValidation;

  /**
   * Mode defines the TLS behavior for the TLS session initiated by the client.
   * There are two possible modes:
   *
   * - Terminate: The TLS session between the downstream client and the
   * Gateway is terminated at the Gateway. This mode requires certificates
   * to be specified in some way, such as populating the certificateRefs
   * field.
   * - Passthrough: The TLS session is NOT terminated by the Gateway. This
   * implies that the Gateway can't decipher the TLS stream except for
   * the ClientHello message of the TLS protocol. The certificateRefs field
   * is ignored in this mode.
   *
   * Support: Core
   *
   * @schema XListenerSetSpecListenersTls#mode
   */
  readonly mode?: XListenerSetSpecListenersTlsMode;

  /**
   * Options are a list of key/value pairs to enable extended TLS
   * configuration for each implementation. For example, configuring the
   * minimum TLS version or supported cipher suites.
   *
   * A set of common keys MAY be defined by the API in the future. To avoid
   * any ambiguity, implementation-specific definitions MUST use
   * domain-prefixed names, such as `example.com/my-custom-option`.
   * Un-prefixed names are reserved for key names defined by Gateway API.
   *
   * Support: Implementation-specific
   *
   * @schema XListenerSetSpecListenersTls#options
   */
  readonly options?: { [key: string]: string };

}

/**
 * Converts an object of type 'XListenerSetSpecListenersTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XListenerSetSpecListenersTls(obj: XListenerSetSpecListenersTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateRefs': obj.certificateRefs?.map(y => toJson_XListenerSetSpecListenersTlsCertificateRefs(y)),
    'frontendValidation': toJson_XListenerSetSpecListenersTlsFrontendValidation(obj.frontendValidation),
    'mode': obj.mode,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RouteGroupKind indicates the group and kind of a Route resource.
 *
 * @schema XListenerSetSpecListenersAllowedRoutesKinds
 */
export interface XListenerSetSpecListenersAllowedRoutesKinds {
  /**
   * Group is the group of the Route.
   *
   * @schema XListenerSetSpecListenersAllowedRoutesKinds#group
   */
  readonly group?: string;

  /**
   * Kind is the kind of the Route.
   *
   * @schema XListenerSetSpecListenersAllowedRoutesKinds#kind
   */
  readonly kind: string;

}

/**
 * Converts an object of type 'XListenerSetSpecListenersAllowedRoutesKinds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XListenerSetSpecListenersAllowedRoutesKinds(obj: XListenerSetSpecListenersAllowedRoutesKinds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces indicates namespaces from which Routes may be attached to this
 * Listener. This is restricted to the namespace of this Gateway by default.
 *
 * Support: Core
 *
 * @schema XListenerSetSpecListenersAllowedRoutesNamespaces
 */
export interface XListenerSetSpecListenersAllowedRoutesNamespaces {
  /**
   * From indicates where Routes will be selected for this Gateway. Possible
   * values are:
   *
   * * All: Routes in all namespaces may be used by this Gateway.
   * * Selector: Routes in namespaces selected by the selector may be used by
   * this Gateway.
   * * Same: Only Routes in the same namespace may be used by this Gateway.
   *
   * Support: Core
   *
   * @schema XListenerSetSpecListenersAllowedRoutesNamespaces#from
   */
  readonly from?: XListenerSetSpecListenersAllowedRoutesNamespacesFrom;

  /**
   * Selector must be specified when From is set to "Selector". In that case,
   * only Routes in Namespaces matching this Selector will be selected by this
   * Gateway. This field is ignored for other values of "From".
   *
   * Support: Core
   *
   * @schema XListenerSetSpecListenersAllowedRoutesNamespaces#selector
   */
  readonly selector?: XListenerSetSpecListenersAllowedRoutesNamespacesSelector;

}

/**
 * Converts an object of type 'XListenerSetSpecListenersAllowedRoutesNamespaces' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XListenerSetSpecListenersAllowedRoutesNamespaces(obj: XListenerSetSpecListenersAllowedRoutesNamespaces | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'selector': toJson_XListenerSetSpecListenersAllowedRoutesNamespacesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretObjectReference identifies an API object including its namespace,
 * defaulting to Secret.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 *
 * @schema XListenerSetSpecListenersTlsCertificateRefs
 */
export interface XListenerSetSpecListenersTlsCertificateRefs {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When unspecified or empty string, core API group is inferred.
   *
   * @schema XListenerSetSpecListenersTlsCertificateRefs#group
   */
  readonly group?: string;

  /**
   * Kind is kind of the referent. For example "Secret".
   *
   * @schema XListenerSetSpecListenersTlsCertificateRefs#kind
   */
  readonly kind?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema XListenerSetSpecListenersTlsCertificateRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema XListenerSetSpecListenersTlsCertificateRefs#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'XListenerSetSpecListenersTlsCertificateRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XListenerSetSpecListenersTlsCertificateRefs(obj: XListenerSetSpecListenersTlsCertificateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FrontendValidation holds configuration information for validating the frontend (client).
 * Setting this field will require clients to send a client certificate
 * required for validation during the TLS handshake. In browsers this may result in a dialog appearing
 * that requests a user to specify the client certificate.
 * The maximum depth of a certificate chain accepted in verification is Implementation specific.
 *
 * Support: Extended
 *
 * @schema XListenerSetSpecListenersTlsFrontendValidation
 */
export interface XListenerSetSpecListenersTlsFrontendValidation {
  /**
   * CACertificateRefs contains one or more references to
   * Kubernetes objects that contain TLS certificates of
   * the Certificate Authorities that can be used
   * as a trust anchor to validate the certificates presented by the client.
   *
   * A single CA certificate reference to a Kubernetes ConfigMap
   * has "Core" support.
   * Implementations MAY choose to support attaching multiple CA certificates to
   * a Listener, but this behavior is implementation-specific.
   *
   * Support: Core - A single reference to a Kubernetes ConfigMap
   * with the CA certificate in a key named `ca.crt`.
   *
   * Support: Implementation-specific (More than one reference, or other kinds
   * of resources).
   *
   * References to a resource in a different namespace are invalid UNLESS there
   * is a ReferenceGrant in the target namespace that allows the certificate
   * to be attached. If a ReferenceGrant does not allow this reference, the
   * "ResolvedRefs" condition MUST be set to False for this listener with the
   * "RefNotPermitted" reason.
   *
   * @schema XListenerSetSpecListenersTlsFrontendValidation#caCertificateRefs
   */
  readonly caCertificateRefs?: XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs[];

}

/**
 * Converts an object of type 'XListenerSetSpecListenersTlsFrontendValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XListenerSetSpecListenersTlsFrontendValidation(obj: XListenerSetSpecListenersTlsFrontendValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificateRefs': obj.caCertificateRefs?.map(y => toJson_XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode defines the TLS behavior for the TLS session initiated by the client.
 * There are two possible modes:
 *
 * - Terminate: The TLS session between the downstream client and the
 * Gateway is terminated at the Gateway. This mode requires certificates
 * to be specified in some way, such as populating the certificateRefs
 * field.
 * - Passthrough: The TLS session is NOT terminated by the Gateway. This
 * implies that the Gateway can't decipher the TLS stream except for
 * the ClientHello message of the TLS protocol. The certificateRefs field
 * is ignored in this mode.
 *
 * Support: Core
 *
 * @schema XListenerSetSpecListenersTlsMode
 */
export enum XListenerSetSpecListenersTlsMode {
  /** Terminate */
  TERMINATE = "Terminate",
  /** Passthrough */
  PASSTHROUGH = "Passthrough",
}

/**
 * From indicates where Routes will be selected for this Gateway. Possible
 * values are:
 *
 * * All: Routes in all namespaces may be used by this Gateway.
 * * Selector: Routes in namespaces selected by the selector may be used by
 * this Gateway.
 * * Same: Only Routes in the same namespace may be used by this Gateway.
 *
 * Support: Core
 *
 * @schema XListenerSetSpecListenersAllowedRoutesNamespacesFrom
 */
export enum XListenerSetSpecListenersAllowedRoutesNamespacesFrom {
  /** All */
  ALL = "All",
  /** Selector */
  SELECTOR = "Selector",
  /** Same */
  SAME = "Same",
}

/**
 * Selector must be specified when From is set to "Selector". In that case,
 * only Routes in Namespaces matching this Selector will be selected by this
 * Gateway. This field is ignored for other values of "From".
 *
 * Support: Core
 *
 * @schema XListenerSetSpecListenersAllowedRoutesNamespacesSelector
 */
export interface XListenerSetSpecListenersAllowedRoutesNamespacesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema XListenerSetSpecListenersAllowedRoutesNamespacesSelector#matchExpressions
   */
  readonly matchExpressions?: XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema XListenerSetSpecListenersAllowedRoutesNamespacesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'XListenerSetSpecListenersAllowedRoutesNamespacesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XListenerSetSpecListenersAllowedRoutesNamespacesSelector(obj: XListenerSetSpecListenersAllowedRoutesNamespacesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectReference identifies an API object including its namespace.
 *
 * The API object must be valid in the cluster; the Group and Kind must
 * be registered in the cluster for this reference to be valid.
 *
 * References to objects with invalid Group and Kind are not valid, and must
 * be rejected by the implementation, with appropriate Conditions set
 * on the containing object.
 *
 * @schema XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs
 */
export interface XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs {
  /**
   * Group is the group of the referent. For example, "gateway.networking.k8s.io".
   * When set to the empty string, core API group is inferred.
   *
   * @schema XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs#group
   */
  readonly group: string;

  /**
   * Kind is kind of the referent. For example "ConfigMap" or "Service".
   *
   * @schema XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs#kind
   */
  readonly kind: string;

  /**
   * Name is the name of the referent.
   *
   * @schema XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of the referenced object. When unspecified, the local
   * namespace is inferred.
   *
   * Note that when a namespace different than the local namespace is specified,
   * a ReferenceGrant object is required in the referent namespace to allow that
   * namespace's owner to accept the reference. See the ReferenceGrant
   * documentation for details.
   *
   * Support: Core
   *
   * @schema XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs(obj: XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions
 */
export interface XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions(obj: XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

